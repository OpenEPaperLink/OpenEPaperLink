/*********************************************************************
*            (c) 1995 - 2018 SEGGER Microcontroller GmbH             *
*                        The Embedded Experts                        *
*                           www.segger.com                           *
**********************************************************************

-------------------------- END-OF-HEADER -----------------------------

File    : CYW208xx_tm.JLinkScript
Purpose : J-Link script file for Infineon CYW20829 devices
Literature:
  [1] J-Link User Guide
  [2] AIROC™ CYW20829 Bluetooth® LE system on chip Programming specification (Document Number: 002-32463)

Additional information:
  For more information about public functions that can be implemented to customize J-Link actions, please refer to [1]
*/

/*********************************************************************
*       Constants
*********************************************************************/

__constant U8 DEBUG_ENABLED                 = 0;          // Enable/disable debug messages in SWD/JTAG traffic

/* --- Target acquisition methods --- */
__constant U8 ACQUIRE_CHECK_IDLE            = (1 << 0);   // Initial check whether boot code is already in IDLE or DEAD branch
__constant U8 ACQUIRE_TEST_MODE             = (1 << 1);   // Test mode (TM) acquisition (recommended)
__constant U8 ACQUIRE_VECTOR_CATCH          = (1 << 2);   // Vector Catch
__constant U8 ACQUIRE_BREAKPOINT            = (1 << 3);   // Alternate acquisition (breakpoint at reset address)
__constant U8 ACQUIRE_METHODS_ALLOWED       = (ACQUIRE_CHECK_IDLE | ACQUIRE_TEST_MODE | ACQUIRE_VECTOR_CATCH | ACQUIRE_BREAKPOINT | 0);

/* --- MCU reset types --- */
__constant U8 RST_TYPE_XRES                 = (1 << 0);   // Hardware reset (XRES)
__constant U8 RST_TYPE_POWER                = (1 << 1);   // Hardware reset (Power Cycle)
__constant U8 RST_TYPE_RES_SOFT_CTL         = (1 << 2);   // Software reset (RES_SOFT_CTL.TRIGGER_SOFT)
__constant U8 RST_TYPE_SYSRESETREQ          = (1 << 3);   // Software reset (AIRCR.SYSRESETREQ)
__constant U8 RST_TYPE_CDBGRSTREQ           = (1 << 4);   // Software reset (DP->CTRL/STAT.CDBGRSTREQ)
__constant U8 RST_TYPE_SOFT                 = (RST_TYPE_RES_SOFT_CTL | RST_TYPE_SYSRESETREQ | RST_TYPE_CDBGRSTREQ | 0);
__constant U8 RST_TYPE_HARD                 = (RST_TYPE_XRES | RST_TYPE_POWER | 0);
__constant U8 RST_TYPE_ANY                  = (RST_TYPE_HARD | RST_TYPE_SOFT | 0);
__constant U8 RST_TYPES_ALLOWED             = (RST_TYPE_XRES | RST_TYPE_RES_SOFT_CTL | RST_TYPE_SYSRESETREQ | RST_TYPE_CDBGRSTREQ | 0);

/* JTag chain setup strig for JLINK_CORESIGHT_Configure() call */
/* Default chain: TDI -> Cortex-M33 (4-bits IRLen) -> Boundary Scan (4-bits IRLen) -> TDO */
const char* JTAG_CHAIN_CONF_STR             = "IRPre=0;DRPre=0;IRPost=4;DRPost=1;IRLenDevice=4;PerformTIFInit=0";

/* --- Access Ports --- */
__constant U8 AP_SYS                        = 0;          // AP[0] System Access Port
__constant U8 AP_CM33                       = 1;          // AP[1] Cortex-M33 Access Port
__constant U8 AP_MAX                        = 2;          // Maximum number of Access Ports for scanning algorithm
__constant U8 AP_TO_USE                     = 1;          // Preferred Access Port (AP[1] - CM33 Core is used by default in this script)
__constant U8 AP_TO_USE_STRICT              = 0;          // "0" - Can use any available AP if needed; "1" - Strict AP usage to preferred only

/* --- SWO Trace configuration --- */
__constant U8 TRACE_div_sel                 = 0;          // Clock divider index to use for cpuss.clock_trace_in peripheral clock. Divider type is CY_SYSCLK_DIV_24_5_BIT
__constant U8 TRACE_div_int                 = 0;          // Integer division by (1+INT24_DIV)
__constant U8 TRACE_div_frac                = 0;          // Fractional division by (FRAC5_DIV/32)
__constant U8 SWO_encode                    = 2;          // SWO encoding mode
                                                          //   0b00 - Parallel trace port mode
                                                          //   0b01 - Asynchronous SWO, using Manchester encoding
                                                          //   0b10 - Asynchronous SWO, using NRZ (UART) encoding

/* --- CYW208xx registers and definitions --- */
__constant U32 MEM_SIZE_ROM                 = 0x00010000; // Size of System ROM
__constant U32 SRAM_DBG_ADDR                = 0x20008000; // Address in SRAM for the debug messages and status.
__constant U32 SRAM_LOOP_ADDR               = 0x20008004; // Address in SRAM for infinite loop.
                                                          // Safe option is to avoid first RAM addresses - the boot code may use up to 32KB of RAM under different circumstances.
__constant U32 SRAM_TOP_ADDR                = 0x2000FFF0; // Top of SRAM address for SP set by acquisition sequence. Use minimum SRAM size
__constant U32 SRAM_STATUS_ADDR             = 0x20000000; // Address in SRAM, where boot code or application stores the status word
__constant U32 SRSS_TST_MODE                = 0x40200400; // SRSS->TST_MODE: Test Mode Control Register
__constant U32 SRSS_TST_MODE_TEST_MODE      = (1 << 31);  // SRSS->TST_MODE.TEST_MODE (bit[31], 0x80000000): 1 - Indicates the chip is in test mode. 0 - Normal operation mode
__constant U32 SRSS_TST_DEBUG_CTL           = 0x40200404; // SRSS->TST_DEBUG_CTL: Debug Control Register
__constant U32 SRSS_TST_DEBUG_CTL_DEBUG_WFA = (1 << 31);  // SRSS->TST_DEBUG_CTL.DEBUG_WFA (bit[31], 0x80000000): Wait for Action. Set by BootROM when it waits for application or
                                                          // debug certificate to be loaded into the RAM. The bit must be cleared to continue BootROM operation.
__constant U32 SRSS_TST_DEBUG_STATUS        = 0x40200408; // SRSS->TST_DEBUG_STATUS: Debug Status Register
__constant U32 SRSS_RES_SOFT_CTL            = 0x40200410; // SRSS->RES_SOFT_CTL: Soft Reset Trigger Register
__constant U32 SRSS_RES_SOFT_CTL_TRIG_SOFT  = (1 << 0);   // SRSS->RES_SOFT_CTL.TRIGGER_SOFT (bit[0]): Triggers a soft reset. The reset clears this bit.
__constant U32 HSIOM_PRT1_PORT_SEL0         = 0x40400010; // MMIO->MMIO1->HSIOM->HSIOM_PRT[1]->PORT_SEL0
__constant U32 GPIO_PRT1_OUT                = 0x40410080; // MMIO->MMIO1->GPIO->GPIO_PRT[1]->OUT
__constant U32 GPIO_PRT1_CFG                = 0x404100C4; // MMIO->MMIO1->GPIO->GPIO_PRT[1]->CFG
__constant U32 PERI_PCLK_GROUP0             = 0x40040000;                // MMIO->MMIO0->PERI_PCLK->PCLK_GROUP[0]
__constant U32 PERI_PCLK_GROUP0_DIV_CMD     = PERI_PCLK_GROUP0 + 0x0000; // MMIO->MMIO0->PERI_PCLK->PCLK_GROUP[0]->DIV_CMD
__constant U32 PERI_PCLK_GROUP0_CLOCK_CTL   = PERI_PCLK_GROUP0 + 0x0C00; // MMIO->MMIO0->PERI_PCLK->PCLK_GROUP[0]->CLOCK_CTL
__constant U32 PERI_PCLK_GROUP0_DIV_24_5_CTL= PERI_PCLK_GROUP0 + 0x1C00; // MMIO->MMIO0->PERI_PCLK->PCLK_GROUP[0]->DIV_24_5_CTL

__constant U32 CYBOOT_ID_MSK                = 0xFFF00000; // Mask for MODULE_ID in status word
__constant U32 CYBOOT_ID_SUCCESS            = 0x0D500000; // The module IDs for BootROM in case of success
__constant U32 CYBOOT_ID_FAIL               = 0xBAF00000; // The module IDs for BootROM in case of fail
__constant U32 CYBOOT_STATUS_MSK            = 0x0000FFFF; // Mask for RESULT_CODE (status) in status word
__constant U32 CYBOOT_NEXT_APP_LAUNCHED     = 0x00000067; // Result code indicating BootROM launched the application
__constant U32 CYBOOT_IDLE_BRANCH_REACHED   = 0x00000068; // Result code indicating BootROM reached IDLE branch

/* --- Debug Access Port (DAP) --- */
__constant U32 DP_IDCODE_MSK                = 0xFFF00FFF; // 0x6BA02477 for SWD or 0x6BA00477 for JTAG
__constant U32 DP_IDCODE_VAL                = 0x6BA00477;
__constant U32 ACC_DP                       = 0;          // APnDP for DP access
__constant U32 ACC_AP                       = 1;          // APnDP for AP access
__constant U32 AP_ABORT_ORUNERRCLR          = (1 << 4);   // AP->ABORT.ORUNERRCLR  (bit[4], 0x00000010): Clears CTRL/STAT.STICKYORUN
__constant U32 AP_ABORT_WDERRCLR            = (1 << 3);   // AP->ABORT.WDERRCLR    (bit[3], 0x00000008): Clears CTRL/STAT.WDATAERR
__constant U32 AP_ABORT_STKERRCLR           = (1 << 2);   // AP->ABORT.STKERRCLR   (bit[2], 0x00000004): Clears CTRL/STAT.STICKYERR
__constant U32 AP_ABORT_STKCMPCLR           = (1 << 1);   // AP->ABORT.STKCMPCLR   (bit[1], 0x00000002): Clears CTRL/STAT.STICKYERR
                                                          // AP->ABORT typical write value: 0x0000001E
__constant U32 AP_SELECT_APSEL_RSH          = 24;         // AP->SELECT.APSEL (bits[31:24], 0xFF000000): Selects an AP
__constant U32 DP_CTRL_CSYSPWRUPREQ         = (1 << 30);  // DP->CTRL/STAT.CSYSPWRUPREQ (bit[30], 0x40000000): System powerup request
__constant U32 DP_CTRL_CDBGPRWUPREQ         = (1 << 28);  // DP->CTRL/STAT.CDBGPRWUPREQ (bit[28], 0x10000000): Debug powerup request
__constant U32 DP_CTRL_CDBGRSTREQ           = (1 << 26);  // DP->CTRL/STAT.CDBGRSTREQ   (bit[26], 0x04000000): Debug reset request
__constant U32 DP_CTRL_STICKYERR            = (1 << 5);   // DP->CTRL/STAT.STICKYERR    ( bit[5], 0x00000020): Error in AP transaction
__constant U32 DP_CTRL_STICKYCMP            = (1 << 4);   // DP->CTRL/STAT.STICKYCMP    ( bit[4], 0x00000010): Match on a pushed operations
__constant U32 DP_CTRL_STICKYORUN           = (1 << 1);   // DP->CTRL/STAT.STICKYORUN   ( bit[1], 0x00000002): Overrun detection
                                                          // DP->CTRL/STAT typical write value is 0x50000032
__constant U32 DP_CSW_PROT_VAL              = (0x23<<24); // DP->CSW.Prot   (bits[30:24], 0x23000000): Bus access protection control. Set to 0x23, otherwise no access to CPU via core AP
__constant U32 DP_CSW_SIZE_WORD             = (2 << 0);   // DP->CSW.Size   (  bits[2:0], 0x00000002): Size of access <- Word (32-bits)
                                                          // DP->CSW typical write value: 0x23000002

/* --- Flash Patch and Breakpoint Unit (FPB) --- */
__constant U32 FP_CTRL                      = 0xE0002000; // FPB->FP_CTRL: FlashPatch Control Register in ARMv7/8-M. In ARMv6-M, it is BP_CTRL: Breakpoint Control register.
__constant U32 FP_CTRL_KEY                  = (1 << 1);   // FPB->FP_CTRL.KEY    (bit[1], 0x00000002): Enables write to the register
__constant U32 FP_CTRL_ENABLE               = (1 << 0);   // FPB->FP_CTRL.ENABLE (bit[0], 0x00000001): Flash Patch global enable. Enables the FPB.
__constant U32 FP_COMP0                     = 0xE0002008; // FPB->FP_COMP0: FlashPatch Comparator Register0 in ARMv7/8-M. In ARMv6-M, it is BP_COMP0: Breakpoint Comparator registers0
                                                          // FPB->FP_COMP.BPADDR ( bits[31:1], 0xFFFFFFFE): Breakpoint address. Note that the bitfields are changed vs. ARMv6/7-M
__constant U32 FP_COMP_BE                   = (1 << 0);   // FPB->FP_COMP.BE     (     bit[0], 0x00000001): Breakpoint enable
/* --- System Control Block (SCB) --- */
__constant U32 CPUID_ADDR                   = 0xE000ED00; // SCB->CPUID Base Register
__constant U32 VTOR_ADDR                    = 0xE000ED08; // SCB->VTOR Vector Table Offset Register
                                                          // Alternative is MXCM33_CM33_NS_VECTOR_TABLE_BASE (0x40161004), which is accessible via CM33-AP (PC1), but not via SYS-AP (PC3).
__constant U32 AIRCR_ADDR                   = 0xE000ED0C; // SCB->AIRCR: Application Interrupt and Reset Control Register
__constant U32 AIRCR_VECTKEY_VAL           =(0x05FA<<16); // SCB->AIRCR.VECTKEY       (bits[31:16], 0x05FA0000): Vector Key. The value 0x05FA must be written to this register
__constant U32 AIRCR_SYSRESETREQ            = (1 << 2);   // SCB->AIRCR.SYSRESETREQ   (     bit[2], 0x00000004): System Reset Request
/* Debug Control Block (DCB) */
__constant U32 DHCSR_ADDR                   = 0xE000EDF0; // DCB->DHCSR: Debug Halting Control and Status Register
__constant U32 DHCSR_DBGKEY_VAL         = (0xA05F << 16); // DCB->DHCSR.DBGKEY    (bits[31:16], 0xA05F0000): Must write 0xA05F to DBGKEY to enable write accesses to bits[15:0]
__constant U32 DHCSR_S_RESET_ST             =  (1 << 25); // DCB->DHCSR.S_RESET_ST(    bit[25], 0x02000000): Reset sticky status. Indicates whether the PE has been reset since the last read of the DHCSR.
__constant U32 DHCSR_S_SLEEP                =  (1 << 18); // DCB->DHCSR.S_SLEEP   (    bit[18], 0x00040000): Indicates whether the processor is sleeping
__constant U32 DHCSR_S_HALT                 =  (1 << 17); // DCB->DHCSR.S_HALT    (    bit[17], 0x00020000): Indicates whether the processor is in Debug state
__constant U32 DHCSR_C_HALT                 =  (1 <<  1); // DCB->DHCSR.C_HALT    (     bit[1], 0x00000002): Processor halt bit
__constant U32 DHCSR_C_DEBUGEN              =  (1 <<  0); // DCB->DHCSR.C_DEBUGEN (     bit[0], 0x00000001): Halting debug enable bit
                                                          //         (DBGKEY|C_HALT|C_DEBUGEN = 0xA05F0003)
__constant U32 DCRSR_ADDR                   = 0xE000EDF4; // DCB->DCRSR: Debug Core Register Selector Register
__constant U32 DCRSR_REGWnR                 =  (1 << 16); // DCB->DCRSR.REGWnR (  bit[16], 0x00010000): Specifies the access type for the transfer ('0' - Read, '1' - Write)
__constant U32 DCRSR_REGSEL_MSK             = 0x0000007F; // DCB->DCRSR.REGSEL (bits[6:0], 0x0000007F): Specifies the ARM core register, special-purpose register, or Floating-point extension register
__constant U32 DCRSR_REGSEL_xPSR            = 0x10;       // DCB->DCRSR.REGSEL = xPSR
__constant U32 DCRSR_REGSEL_MSP             = 0x11;       // DCB->DCRSR.REGSEL = Main stack pointer, MSP
__constant U32 DCRSR_REGSEL_PC              = 0x0F;       // DCB->DCRSR.REGSEL = PC / DebugReturnAddress
__constant U32 DCRDR_ADDR                   = 0xE000EDF8; // DCB->DCRDR: Debug Core Register Data Register
__constant U32 DEMCR_ADDR                   = 0xE000EDFC; // DCB->DEMCR: Debug Exception and Monitor Control Register
__constant U32 DEMCR_VC_CORERESET           =  (1 <<  0); // DCB->DEMCR.VC_CORERESET ( bit[0], 0x00000001): Reset Vector Catch. Halt running system if Core reset occurs.
__constant U32 DEMCR_TRCENA                 =  (1 << 24); // DCB->DEMCR.TRCENA       (bit[24], 0x01000000): Global enable for all DWT and ITM features
__constant U32 xPSR_T                       =  (1 << 24); // xPSR.T (bit[24], 0x01000000): Thumb bit

__constant U32 TPIU_BASE                    = 0xE008E000; // TPIU Base Address. Different from the default address in CMSIS headers (0xE0040000).
__constant U32 ITM_BASE                     = 0xE0000000; // ITM Base Address @0xE0000000
__constant U32 DWT_BASE                     = 0xE0001000; // DWT Base Address @0xE0001000
__constant U32 TPIU_ACPR             = TPIU_BASE + 0x010; // TPIU Asynchronous Clock Prescaler Register @0xE008E010. Defines a prescaler value for the baud rate of the Serial Wire Output (SWO).
                                                          // Writing to the register automatically updates the prescale counter, immediately affecting the baud rate of the serial data output.
__constant U32 TPIU_SPPR             = TPIU_BASE + 0x0F0; // TPIU Selected Pin Protocol Register @0xE008E0F0. Selects the protocol used for trace output.
__constant U32 TPIU_FFCR             = TPIU_BASE + 0x304; // TPIU Formatter and Flush Control Register @0xE008E304. Controls the TPIU formatter.
__constant U32 ITM_TER0              = ITM_BASE  + 0xE00; // ITM Trace Enable Register [0] @0xE0000E00. Provides individual enable bits for ITM_STIM[0..31] registers.
__constant U32 ITM_TPR               = ITM_BASE  + 0xE40; // ITM Trace Privilege Register @0xE0000E40. Controls which stimulus ports can be accessed by unprivileged code.
__constant U32 ITM_TCR               = ITM_BASE  + 0xE80; // ITM Trace Control Register @0xE0000E80. Configures and controls transfers through the ITM interface.
__constant U32 ITM_LAR               = ITM_BASE  + 0xFB0; // ITM Software Lock Access Register @0xE0000FB0 (Armv8-M and newer). Provides CoreSight Software Lock control for the ITM.
__constant U32 DWT_CTRL              = DWT_BASE  + 0x000; // DWT Control Register @0xE0001000. Provides configuration and status information.

/* --- Misc. --- */
__constant int RESULT_OK                    = 0;          // Function return result: O.K.
__constant int RESULT_ERR                   = -1;         // Function return result: Error
__constant int RESULT_ERR_CRITICAL          = -15;        // Function return result: Critical Error
__constant U32 ERR_ADDR_MSK                 = 0xF0000000; // Error mask for SP and PC values
__constant U32 TIMEOUT_HANDSHAKE            = 2500;       // Timeout for the maximum possible boot time until the debug interface is enabled
__constant U32 TIMEOUT_HANDSHAKE_SMALL      = 5;          // Small timeout for the handshake when performed not after reset
__constant U32 TIMEOUT_LISTEN_WND           = 150;        // Timeout for Listen window duration (100ms max)
__constant U32 TIMEOUT_HALT_CPU             = 10;         // Timeout for CPU halt/unhalt actions
__constant U32 TEST_MODE_SWD_SPEED          = 4000;
__constant U32 LOOP_CODE                    = 0xE7FEE7FE; // Endless loop


/*********************************************************************
*       Static data
*********************************************************************/

// Standard ARM command to switch SWJ-DP from JTAG to SWD operations:
const U8 _aData_JTAGtoSWD[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,      // Send at least 50 SWCLKTCK cycles with SWDIOTMS HIGH. This ensures that the current interface is in its reset state.
                                                 // The JTAG interface detects only the 16-bit JTAG-to-SWD sequence starting from the test-logic-reset state.
  0x9E, 0xE7,                                    // Send the 16-bit JTAG-to-SWD select sequence on SWDIOTMS: 0b0111 1001 1110 0111, most significant bit (MSb) first.
                                                 // This can be represented as 0x79E7, transmitted MSB first or 0xE79E, transmitted least significant bit (LSb) first.
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,      // Send at least 50 SWCLKTCK cycles with SWDIOTMS HIGH. This ensures that if SWJ-DP was already in SWD operation
                                                 // before sending the select sequence, the SWD interface enters the line reset state.
  0x00, 0x00                                     // Make sure SWD is ready for a start bit (min. 2 clocks with SWDIO == LOW)
};

// Standard ARM command to switch SWJ-DP from SWD to JTAG operations
const U8 _aData_SWDtoJTAG[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,      // Send at least 50 SWCLKTCK cycles with SWDIOTMS HIGH. This ensures that the current interface is in its reset state.
                                                 // The SWD interface detects the 16-bit SWD-to-JTAG sequence only when it is in the reset state.
  0x3C, 0xE7,                                    // Send the 16-bit SWD-to-JTAG select sequence on SWDIOTMS: 0b0011 1100 1110 0111, MSb first.
                                                 // This can be represented as 0x3CE7, transmitted MSb first or 0xE73C, transmitted LSb first.
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,      // Send at least five SWCLKTCK cycles with SWDIOTMS HIGH. This ensures that if SWJ-DP was already in JTAG
                                                 // operation before sending the select sequence, the JTAG TAP enters the test-logic-reset state.
  0x00, 0x00                                     // Make sure SWD is ready for a start bit (min. 2 clocks with SWDIO == LOW)
};

// Direction buffer
const U8 _aDir_SWJDPSwitch[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF
};

// Buffer for receiving data from the target. Needs to be big enough to hold data for the above sequences
U8 _aDataOut[18];

/*********************************************************************
*       Local functions
*********************************************************************/

/*********************************************************************
* Checks internal and J-Link functions return codes:
*  ≥ 0 O.K.
*  < 0 Error
*  = -2 Not supported by the current CPU + target interface combination
*
* Return value
*   0  SUCCEEDED
*   1  FAILED
*/
int SUCCEEDED(int result) {
  if(result >= 0) { return 1; }
  else { return 0; }
}

/*********************************************************************
* Checks internal and J-Link functions return codes:
*  ≥ 0 O.K.
*  < 0 Error
*  = -2 Not supported by the current CPU + target interface combination
*
* Return value
*   0  SUCCEEDED
*   1  FAILED
*/
int FAILED(int result) {
  if(result < 0) { return 1; }
  else { return 0; }
}

/*********************************************************************
* Reads U32 value from the provided memory address.
* Used instead of JLINK_MEM_ReadU32 to validate transaction status
*
* Return value
*   0  SUCCEEDED
*   1  FAILED
*/
int _ReadMem(U32 address, U32* value) {
  int result;

  if (JLINK_ActiveTIF == JLINK_TIF_JTAG) {
    *value = JLINK_MEM_ReadU32(address);
    result = RESULT_OK;
  }
  else { // SWD
    // AP.TAR <- address
    result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_AP_REG_ADDR, ACC_AP, address);
    if (SUCCEEDED(result)) {
      // AP.DRW -> value
      result = JLINK_CORESIGHT_ReadDAP(JLINK_CORESIGHT_AP_REG_DATA, ACC_AP, value);
    }
  }

  return result;
}

/*********************************************************************
* Writes U32 value to the provided memory address.
* Used instead of JLINK_MEM_WriteU32 to validate transaction status
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _WriteMem(U32 address, U32 value) {
  int result;

  if (JLINK_ActiveTIF == JLINK_TIF_JTAG) {
    result = JLINK_MEM_WriteU32(address, value);
  }
  else {
    // AP.TAR <- address
    result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_AP_REG_ADDR, ACC_AP, address);
    if (SUCCEEDED(result)) {
      // AP.DRW <- value
      result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_AP_REG_DATA, ACC_AP, value);
    }
  }  

  return result;
}

/*********************************************************************
* Puts the recognizable pattern to SWD. For debug purposes only.
*/
void _DebugSWD(U32 result) {
  if (DEBUG_ENABLED != 0) {
    if (FAILED(result)) {
      _WriteMem(SRAM_DBG_ADDR, 0xDEADBEEF);
      _WriteMem(SRAM_DBG_ADDR, 0xDEADBEEF);
    }
    else {
      _WriteMem(SRAM_DBG_ADDR, 0xDABBAD00);
      _WriteMem(SRAM_DBG_ADDR, 0xDABBAD00);
    }
  }
}

/*********************************************************************
* Polls for the expected bit-field value in the given register
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _PollMem(U32 regAddr, U32 fieldMsk, U32 rsh, U32 expectedValue, U32 timeout, U32 sleepBetweenPolling, U32* regValue) {
  int result;
  int t;
  int tDelta;
  tDelta = -1;
  result = RESULT_ERR;

    t = JLINK_GetTime();
    do {
    result = _ReadMem(regAddr, regValue);
    if (FAILED(result)) {
      break;
    }
    if (((*regValue & fieldMsk) >> rsh) == expectedValue) {
      result = RESULT_OK;
      break;
    }
    // Sleep between polling - let the CPU do its job and avoid too much garbage on SWD
    if ((sleepBetweenPolling > 0) && (tDelta >= 0 /* not first iteration*/)) {
      JLINK_SYS_Sleep(sleepBetweenPolling);
    }
    tDelta = JLINK_GetTime() - t;
  } while (tDelta < timeout);

  return result;
}

/*********************************************************************
* Reads ARM core register, special-purpose register, or Floating-point extension register
* CPU must be halted for this operation
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _ReadCoreReg(U32 regsel, U32* value) {
  int result;

  // DCRSR (0xE000EDF4) <- (REGWnR == read) | REGSEL
  result = _WriteMem(DCRSR_ADDR, (regsel & DCRSR_REGSEL_MSK));
  if (SUCCEEDED(result)) {
    // DCRDR (0xE000EDF8) -> value
    result = _ReadMem(DCRDR_ADDR, value);
  }

  return result; 
}

/*********************************************************************
* Writes ARM core register, special-purpose register, or Floating-point extension register
* CPU must be halted for this operation
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _WriteCoreReg(U32 regsel, U32 value) {
  int result;

  // DCRDR (0xE000EDF8) <- value
  result = _WriteMem(DCRDR_ADDR, value);
  if (SUCCEEDED(result)) {
    // DCRSR (0xE000EDF4) <- (REGWnR == write) | REGSEL
    result = _WriteMem(DCRSR_ADDR, (DCRSR_REGWnR | (regsel & DCRSR_REGSEL_MSK)));
  }

  return result; 
}

/*********************************************************************
* Handshake: wait for debug interface to become enabled after device reset.
* In the worst case, when the boot code performs application HASH verification,
* boot time is around 2500ms and depends on CPU clock used by the boot code.
* For PowerCycle, timeout depends on the design schematic and must be longer.
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
* Notes
*   (1) Must not use any high-level functions as it is also called from InitTarget() and uses non-standard APs etc.
*/
int _Handshake(U32 timeout) {
  U32 v;
  int t;
  int tDelta;
  int result;

  result = RESULT_ERR;
  t = JLINK_GetTime();
  do {
    if (JLINK_ActiveTIF == JLINK_TIF_JTAG) {
      JLINK_CORESIGHT_Configure(JTAG_CHAIN_CONF_STR);
      JLINK_JTAG_ReadWriteBits(&_aDir_SWJDPSwitch[0], &_aData_SWDtoJTAG[0], &_aDataOut[0], 18 * 8);
      JLINK_JTAG_WriteIR(0xFE);     // IR <- IDCODE
      JLINK_JTAG_StartDR();         // Select-DR
      JLINK_JTAG_WriteDREnd(0, 32); // Shift DR out to get the 32-bit IDCODE value
      v = JLINK_JTAG_GetU32(3);     // Get DR from a stream skipping 3 ACK bits
    } else { // JLINK_ActiveTIF == JLINK_TIF_SWD
      JLINK_SWD_ReadWriteBits(&_aData_JTAGtoSWD[0], &_aDir_SWJDPSwitch[0], &_aDataOut[0], 18 * 8);
      v = JLINK_CORESIGHT_ReadDP(JLINK_CORESIGHT_DP_REG_IDCODE);
    }

    if ((v & DP_IDCODE_MSK) == DP_IDCODE_VAL) { // DAP is responsive if we can read IDCODE (0x6BA02477 for SWD or 0x6BA00477 for JTAG)
      result = RESULT_OK;
      break;
    }
    tDelta = JLINK_GetTime() - t;
  } while (tDelta < timeout); // Timeout reached?

  return result;
}

/*********************************************************************
* Initialize the Debug Port for programming operations.
* Accepts Access Port number as input: 0 – System AP; 1 – CM33 AP.
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
* Notes
*   (1) Must not use any high-level functions as it is also called from InitTarget() and uses non-standard APs etc.
*/
int _DAP_Init(U8 apNum) {
  int result;

  // Power up DAP using DP.CTRL/STAT: [30]:CSYSPWRUPREQ, [28]:CDBGPWRUPREQ
  // Clear sticky errors:
  // - SWD:  Using AP.ABORT register
  // - JTAG: Using DP.CTRL/STAT: [5]:STICKYERR, [4]:STICKYCMP, [1]:STICKYORUN
  //   For JTAG, sticky error bits are read-write enabled and writing '1' to these bits clears associated sticky errors.
  //   For SWD, these bits are read-only and to clean the sticky errors, you should write to appropriate bits of DP.ABORT register
  if (JLINK_ActiveTIF == JLINK_TIF_JTAG) {
    result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_DP_REG_CTRL_STAT, ACC_DP, DP_CTRL_CSYSPWRUPREQ | DP_CTRL_CDBGPRWUPREQ | DP_CTRL_STICKYERR /* 0x50000020 */);
  } else { // SWD
    result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_DP_REG_ABORT, ACC_DP, AP_ABORT_ORUNERRCLR | AP_ABORT_WDERRCLR | AP_ABORT_STKERRCLR | AP_ABORT_STKCMPCLR /* 0x0000001E */);
    if (SUCCEEDED(result)) {
      result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_DP_REG_CTRL_STAT, ACC_DP, DP_CTRL_CSYSPWRUPREQ | DP_CTRL_CDBGPRWUPREQ); // 0x50000000
    }
  }

  if (SUCCEEDED(result)) {
    // Select desired Access Port and set bank 0 in APACC space
    result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_DP_REG_SELECT, ACC_DP, (apNum << AP_SELECT_APSEL_RSH) ); // DP->SELECT.APSEL <- apNum
    if (SUCCEEDED(result)) {
      // Set CSW (DbgSwEnable=0, Prot=0x23, SPIDEN=0, Mode=0x0, TrInProg=0, DeviceEn=0, AddrInc=Auto-increment off, Size=Word (32 bits))
      // Note: Set Prot bits in DAP CSW register, because of no access to CPU registers via M33 AP without these bits
      result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_AP_REG_CTRL, ACC_AP, DP_CSW_PROT_VAL | DP_CSW_SIZE_WORD); // 0x23000002
    }
  }

  return result;
}

/*********************************************************************
* Performs Handshake and Initializes the Debug Port
* Accepts Access Port number as input: 0 – System AP; 1 – CM33 AP.
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
* Notes
*   (1) Must not use any high-level functions as it is also called from InitTarget() and uses non-standard APs etc.
*/
int _DAP_HandshakeAndInit(U8 apNum, U32 timeout) {
  int result;

  result = _Handshake(timeout);
  if (SUCCEEDED(result)) {
    result = _DAP_Init(apNum);
    if (SUCCEEDED(result)) {
    }
  }

  return result;
}

/*********************************************************************
* Scans the Access Ports for the first available with CPU registers access.
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
* Notes
*   (1) Must not use any high-level functions as it is also called from InitTarget() and uses non-standard APs etc.
*/
int _DAP_ScanAP(U8* apNum) {
  U32 v;
  U8 currAP;
  int result;
  
  // Try all possible Access Ports  
  currAP = 0;
  while (currAP < AP_MAX) {
    if (currAP != AP_SYS) {      
      // Initializes DAP and selects Access Port with provided number
      result = _DAP_Init(currAP);
      if (SUCCEEDED(result)) {
        // Try to read CPUID register @0xE000ED00
        result = _ReadMem(CPUID_ADDR, &v);
        // If the CPUID Implementer is ARM, the Access Port is correct (we have access to the ARM registers)
        if (SUCCEEDED(result) && ((v & 0xFF000000) == 0x41000000)) {
          *apNum = currAP;
          return RESULT_OK;
        }
      }
    }
    currAP += 1;
  }

  return RESULT_ERR;
}

/*********************************************************************
* Resets the device using either of:
*   1. Hardware reset by toggling XRES pin
*   2. Software reset by setting the RES_SOFT_CTL.TRIGGER_SOFT bit
*   3. Software reset by setting the AIRCR.SYSRESETREQ bit
*   4. Software reset by setting the DP->CTRL/STAT.CDBGRSTREQ bit
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _Reset(U8 rstType, U8 apNum) {
  int result;  
  result = RESULT_ERR;

  // Attempt to reset the device with different methods
  // Note1: do not check OK/WAIT/FAULT ACKs for the data write phase since the target immediately reboots
  // Note2: caller code needs to do Handshake and DAP Init after reset or in case of failure

  // 1. Hardware reset by toggling XRES pin
  if ((rstType & RST_TYPE_XRES) != 0) {
    JLINK_JTAG_ResetPin = 0; // nRESET == LOW
    JLINK_SYS_Sleep(50);     // Make sure that device recognizes the reset
    JLINK_JTAG_ResetPin = 1; // nRESET == HIGH
    result = RESULT_OK;
  }

  // 2. Software reset by setting the RES_SOFT_CTL.TRIGGER_SOFT bit:
  //    This type of software reset can work via SYS-AP, so it is more preferable vs. SYSRESETREQ
  if (FAILED(result) && ((rstType & RST_TYPE_RES_SOFT_CTL) != 0)) {
    // AP.TAR <- @(SRSS->RES_SOFT_CTL) 
    result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_AP_REG_ADDR, ACC_AP, SRSS_RES_SOFT_CTL);
    if (FAILED(result)) {
      result = _DAP_HandshakeAndInit(apNum, TIMEOUT_HANDSHAKE);
      if (SUCCEEDED(result)) {
        result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_AP_REG_ADDR, ACC_AP, SRSS_RES_SOFT_CTL);
      }
    }
    // AP.DRW <- TRIGGER_SOFT bit
    if (SUCCEEDED(result)) {
      JLINK_CORESIGHT_WriteAP(JLINK_CORESIGHT_AP_REG_DATA, SRSS_RES_SOFT_CTL_TRIG_SOFT );
    }
  }

  // 3. Software reset by setting the AIRCR.SYSRESETREQ bit
  if (FAILED(result) && ((rstType & RST_TYPE_SYSRESETREQ) != 0) && (apNum != AP_SYS)) {
    // AP.TAR <- @(AIRCR 0xE000ED0C)
    result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_AP_REG_ADDR, ACC_AP, AIRCR_ADDR);
    if (FAILED(result)) {
      result = _DAP_HandshakeAndInit(apNum, TIMEOUT_HANDSHAKE);
      if (SUCCEEDED(result)) {
        result = JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_AP_REG_ADDR, ACC_AP, AIRCR_ADDR);
      }
    }
    // AP.DRW <- 0x05FA0004
    if (SUCCEEDED(result)) {
      JLINK_CORESIGHT_WriteAP(JLINK_CORESIGHT_AP_REG_DATA, (AIRCR_VECTKEY_VAL | AIRCR_SYSRESETREQ) );
    }
  }

  // 4. Software reset by setting the DP->CTRL/STAT.CDBGRSTREQ bit
  //    In the worst case, if standard software reset via SYSRESETREQ failed, it may mean that the firmware did
  //    very bad things disabling the debug pins or AHB_AP access (anything behind the DAP).
  //    However, if we still can access the DAP registers, the last thing we could try is to reset the target
  //    via DP->CTRL/STAT.CDBGRSTREQ. In CAT1 and CAT2 devices, setting the CDBGRSTREQ bit will result in a
  //    System-wide Debug DeepSleep reset, which also resets the Cortex core.
  //    Note that CDBGRSTREQ will reset the target only at the first attempt after the hardware reset (XRES or Power Cycle).
  //    You need to do the additional hardware reset manually before the acquisition sequence execution if the target
  //    stuck in a 'bad' state and you already used the CDBGRSTREQ bit since the previous hardware reset.
  //    If such a case happens and we managed to reset the target using CDBGRSTREQ,
  //    the next thing would be to halt the CPU as quickly as possible to prevent firmware to do the bad things again.
  if (FAILED(result) && ((rstType & RST_TYPE_CDBGRSTREQ) != 0) ) {
    result = _Handshake(TIMEOUT_HANDSHAKE);
    if (SUCCEEDED(result)) {
      JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT, DP_CTRL_CSYSPWRUPREQ | DP_CTRL_CDBGPRWUPREQ | DP_CTRL_CDBGRSTREQ); // 0x54000000
    }
  }

  return result;
}

/*********************************************************************
* Enables debug and halts the CPU using the DHCSR register
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _HaltCPU(void) {
  int result;
  U32 v;

  // Enable debug, and halt the CPU using the DHCSR register: 0xE000EDF0 <- 0xA05F0003
  result = _WriteMem(DHCSR_ADDR, DHCSR_DBGKEY_VAL | DHCSR_C_HALT | DHCSR_C_DEBUGEN);

  // Check S_HALT bit [17] in DHCSR register (@0xE000EDF0)
  // *Most* time, S_HALT bit is set immediately and correct value is read here.
  // This will eliminates excessive polling and keeps SWD traffic clear
  if (SUCCEEDED(result)) {
    result = _PollMem(DHCSR_ADDR, DHCSR_S_HALT, 0, DHCSR_S_HALT, TIMEOUT_HALT_CPU, 0, &v);
  }

  return result;
}

/*********************************************************************
* Enables resumes the CPU using the DHCSR register
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _ResumeCPU(void) {
  int result;
  U32 v;

  // Resume CPU (keeping debug enabled) using the DHCSR register: 0xE000EDF0 <- 0xA05F0001
  result = _WriteMem(DHCSR_ADDR, DHCSR_DBGKEY_VAL | DHCSR_C_DEBUGEN);

  // Check S_HALT (bit[17] in DHCSR register @0xE000EDF0) is cleared
  // *Most* time, S_HALT bit is cleared immediately and correct value is read here.
  // This will eliminates excessive polling and keeps SWD traffic clear
  if (SUCCEEDED(result)) {
    result = _PollMem(DHCSR_ADDR, DHCSR_S_HALT, 0, 0, TIMEOUT_HALT_CPU, 0, &v);
  }

  return result;
}

/*********************************************************************
* Reads PC and checks it points to address in ROM
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _IsPCInROM(int doHaltCPU) {
  int result;
  U32 v;
  result = RESULT_OK;

  // CPU must be halted to read the PC
  if (doHaltCPU) {
    result = _HaltCPU();
  }
  if (SUCCEEDED(result)) {
    result = _ReadCoreReg(DCRSR_REGSEL_PC, &v);
    if (FAILED(result) || (v >= MEM_SIZE_ROM)) {
      result = RESULT_ERR;
    }
  }

  return result;  
}

/*********************************************************************
* Gets Reset Address and Initial SP values from application Vector Table
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _GetVectorTableData(U32* resetAddress, U32* sp) {
  int result;
  U32 v;
  U32 vtBase;

  *resetAddress = 0;
  *sp = 0;

  // Check Vector Table base address for Cortex core.
  // Note: Zero in Vector Table base register or in reset address (reset handler + 4) likely indicates that
  //       the target is in VIRGIN (preproduction) state, so the ROM boot code debugging is enabled.
  result = _ReadMem(VTOR_ADDR, &vtBase);

  if (vtBase == 0) {
    vtBase = 0x20004000;
  }

  if (SUCCEEDED(result) && ((vtBase & ERR_ADDR_MSK) != ERR_ADDR_MSK)) {

    // Get Reset Address from Vector Table
    result = _ReadMem(vtBase + 4, &v);
    if (SUCCEEDED(result) && ((v & ERR_ADDR_MSK) != ERR_ADDR_MSK)) {
      *resetAddress = v;

      // Get Initial SP value from Vector Table
      result = _ReadMem(vtBase, &v);
      if (SUCCEEDED(result) && (v != 0) && ((v & ERR_ADDR_MSK) != ERR_ADDR_MSK)) {
        *sp = v;

      } else { result = RESULT_ERR; }
    } else { result = RESULT_ERR; }
  } else { result = RESULT_ERR; }
  
  return result;
}

/*********************************************************************
* Sets PC and SP getting the values from Vector Table
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _SetPCandSPFromVectorTable(void) {
  int result;
  U32 v;
  U32 pc;
  U32 sp;

  // Get PC and SP for the application in flash
  result = _GetVectorTableData(&pc, &sp); 
  if (SUCCEEDED(result) && ((pc & ERR_ADDR_MSK) != ERR_ADDR_MSK) && ((sp & ERR_ADDR_MSK) != ERR_ADDR_MSK)) {
  
    // Set PC
    result = _WriteCoreReg(DCRSR_REGSEL_PC, pc);
    if (SUCCEEDED(result)) {

      // Set MSP
      result = _WriteCoreReg(DCRSR_REGSEL_MSP, sp);
      if (SUCCEEDED(result)) {

        //Read xPSR register, set the thumb bit, and restore modified value to xPSR register
        result = _ReadCoreReg(DCRSR_REGSEL_xPSR, &v);
        if (SUCCEEDED(result)) {
          result = _WriteCoreReg(DCRSR_REGSEL_xPSR, (v | xPSR_T) );
        }
      }
    }
  } else { result = RESULT_ERR; }

  return result;
}

/*********************************************************************
* Check if the device is in IDLE or DEAD branches,
* what is a sufficient condition for programming
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _IsBootIdle(U8 apNum, U32* stopPolling) {
  int result;
  U32 v;
  *stopPolling = 0;

  // Read SRSS->TST_DEBUG_CTL register and check the WFA bit is set, indicating a special mode with
  // additional restrictions for debugger. Normal programming/debugging is not possible - need reset/acquire
  result = _ReadMem(SRSS_TST_DEBUG_CTL, &v);
  if (SUCCEEDED(result)) {
    if ((v & SRSS_TST_DEBUG_CTL_DEBUG_WFA) != 0) {
      *stopPolling = 1; // WFA branch, no sense to continue polling - need to do reset/acquire
      result = RESULT_ERR;
    }
  }

  // Check the status reported by boot code in RAM. Both, DEAD and IDLE branches are sufficient for programming
  if (SUCCEEDED(result)) {
    result = _ReadMem(SRAM_STATUS_ADDR, &v);
    if (SUCCEEDED(result)) {
      if (((v & CYBOOT_ID_MSK) == CYBOOT_ID_SUCCESS) && ((v & CYBOOT_STATUS_MSK) == CYBOOT_NEXT_APP_LAUNCHED)) {
        *stopPolling = 1; // Not IDLE branch, application launched, no sense to continue polling
        result = RESULT_ERR;
      } else {
        if ( ((v & CYBOOT_ID_MSK) != CYBOOT_ID_FAIL) && // Not DEAD branch
             ((v & CYBOOT_ID_MSK) != CYBOOT_ID_SUCCESS))  {
          result = RESULT_ERR;  // No status word
        }
      }
    }
  }

  return result;
}

/*********************************************************************
* Waits for the device to be in IDLE or DEAD branches
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _WaitForBootIdle(U8 apNum, U32 timeout, U8 checkPCinROM) {
  int result;
  int t;
  int tDelta;
  U32 stopPolling;
  tDelta = -1;

  result = _IsBootIdle(apNum, &stopPolling);
  if (FAILED(result) && (result != RESULT_ERR_CRITICAL) && (stopPolling == 0)) {
    t = JLINK_GetTime();
    do {
      // Sleep between polling - let the target do its job and avoid too much garbage on SWD
      JLINK_SYS_Sleep(1);
      result = _IsBootIdle(apNum, &stopPolling);
      if (SUCCEEDED(result) || (result == RESULT_ERR_CRITICAL) || (stopPolling != 0)) {
        // No sense to wait if target is in CORRUPTED state (result == RESULT_ERR_CRITICAL) or
        // in WFA branch or when the application is already launched (stopPolling != 0)
        break;
      }
      tDelta = JLINK_GetTime() - t;
    } while (tDelta < timeout);
  }

  // Additionally, check PC points to address in ROM, but not in RAM or in FLASH
  if (SUCCEEDED(result) && (checkPCinROM != 0) && (apNum != AP_SYS)) {
    result = _IsPCInROM(1 /* "1" - Do Halt CPU */);
  }

  return result;
}

/*********************************************************************
* Performs device acquisition in test mode:
*   1. Pre-reset (do hardware (XRES) or one of the software reset) and connect to the DAP
*   2. Set TEST_MODE bit in TST_MODE SRSS register
*   3. Poll for the IDLE status set by boot code in RAM
*   4. Prepares target for debug
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
* Notes
*   (1) Must not use any high-level functions as it is also called from InitTarget() and uses non-standard APs etc.
*/
int _AcquireTestMode(U8 rstType, U8 apNum) {
  int result;
  U32 v;
  U32 OrgTIFSpeed;

  // Make sure that J-Link is using a high target interface speed, so we can meet the timing requirements as per programming specifications
  // Might be necessary for some IDEs that select a very slow interface speed by default and do not allow to change this
  OrgTIFSpeed = JLINK_JTAG_Speed;
  JLINK_JTAG_Speed = TEST_MODE_SWD_SPEED;

  // Preconfigure some CoreSight settings as time is not critical at this point
  // E.g. by default, when executing DAP API calls from within the firmware, J-Link will do a retry of the DAP transfer for some interfaces, if we got an invalid response from the DAP.
  // As this costs valuable time here, we temporarily disable this behavior and restore it at the end of the call.
  // Additionally, suppress output of the JTAG/SWD switching sequence init at the end of the CORESIGHT_Configure() call, as we do not need it and it only costs time
  JLINK_CORESIGHT_Configure("RetryOnInvalDAPResp=0;PerformTIFInit=0");

  // 1. Pre-reset (do hardware (XRES) or one of the software reset) and connect to the DAP
  // --------------------------------------------------------------------------------
  // a. Do hardware (XRES) or one of the software reset
  //    It is critical for Test Mode acquisition, so stop in case of failure
  // b. Handshake (wait for debug interface to become enabled after device reset),
  //    initialize the Debug Port, and select the appropriate Access Port (AP)
  result = _Reset(rstType, apNum);
  if (SUCCEEDED(result)) {
    result = _DAP_HandshakeAndInit(apNum, TIMEOUT_HANDSHAKE);
  }

  // 2. Set TEST_MODE bit in TST_MODE SRSS register
  // --------------------------------------------------------------------------------
  if (SUCCEEDED(result)) {
    JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_AP_REG_ADDR, ACC_AP, SRSS_TST_MODE);
    JLINK_CORESIGHT_WriteDAP(JLINK_CORESIGHT_AP_REG_DATA, ACC_AP, SRSS_TST_MODE_TEST_MODE);   
    // Read RDBUFF to make sure that the last AP write actually happens as SW-DP may buffer/delay it until next DAP access
    JLINK_CORESIGHT_ReadDAP(JLINK_CORESIGHT_DP_REG_RDBUF, ACC_DP, &v);
  }
    
  // The steps above are time-critical and must be executed without delays immediately after reset.
  // No hurry for further steps - target already acquired in Test mode

  // Restore CORESIGHT settings (See beginning of this function call for more info) and restore original TIF speed
  JLINK_CORESIGHT_Configure("RetryOnInvalDAPResp=1;PerformTIFInit=0");
  JLINK_JTAG_Speed = OrgTIFSpeed;

  // 3. Poll for the IDLE status set by boot code and check PC points to address in ROM
  result = _WaitForBootIdle(apNum, TIMEOUT_LISTEN_WND, 1 /* "1" - Check PC in ROM */);
  
  // 4. Prepares target for debug
  // --------------------------------------------------------------------------------
  // a. Clear TEST_MODE bit in SRSS->TST_MODE.TEST_MODE register
  // b. Set SP and PC values from the vector table
  //    Needs to be done after Test mode acquisition to withdraw the target from the IDLE loop
  //    Otherwise, such commands as "go" or "step" will not work after acquisition
  //    Do not check for the result since there might be no valid application so no possibility
  //    to set the PC to the ResetHandler, acquisition step is still succeedded
  if (SUCCEEDED(result)) {
    result = _WriteMem(SRSS_TST_MODE, 0);
    if (SUCCEEDED(result) && (apNum != AP_SYS)) {
      _SetPCandSPFromVectorTable();
    }
  }

  _DebugSWD(result);

  return result;
}

/*********************************************************************
* Performs target acquisition using Vector Catch:
*   1. Pre-reset (do hardware (XRES) or one of the software reset) and connect to the DAP
*   2. Halt CPU, set DEMCR->VC_CORERESET, and issue software reset
*   3. Connect to the DAP and check CPU is halted
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
* Notes
*   (1) Must not use any high-level functions as it is also called from InitTarget() and uses non-standard APs etc.
*/
int _AcquireVectorCatch(U8 rstType, U8 apNum) {
  int result;
  int resultTmp;
  U32 v;
  U32 v1;
  result = RESULT_OK;

  // 1. Pre-reset and connect
  // --------------------------------------------------------------------------------
  // a. Pre-reset (do hardware (XRES) or one of the software reset) and connect to the DAP
  //    Pre-reset is not critical for the Vector Catch acquisition,
  //    so do not check for the result and do not stop if it is failed
  // b. Handshake (wait for debug interface to become enabled after device reset),
  //    initialize the Debug Port and select appropriate Access Port (AP) with the CPU access
  if (apNum == AP_SYS) {
    // It is not possible to handle CPU state (e.g. breakpoints) via the System Access Port
    result = RESULT_ERR;
  } else {
    _Reset(rstType, apNum);
    result = _DAP_HandshakeAndInit(apNum, TIMEOUT_HANDSHAKE);
  }

  // 2. Halt CPU, set DEMCR->VC_CORERESET, and issue software reset
  // --------------------------------------------------------------------------------
  // a. Enable debug and halt CPU as quickly as possible right after Reset+Handshake+InitDAP
  //    It is not mandatory to do this quickly, but there is a good chance to stop
  //    in Listen window or at least prevent user application from doing too much "bad" stuff
  // b. Set VC_CORERESET and TRCENA bits in DEMCR register
  // c. Issue software reset
  if (SUCCEEDED(result)) {
    result = _HaltCPU();
    if (SUCCEEDED(result)) {
      // Set VC_CORERESET and TRCENA: DEMCR (0xE000EDFC) = 0x01000001
      result = _WriteMem(DEMCR_ADDR, DEMCR_TRCENA | DEMCR_VC_CORERESET);
      if(SUCCEEDED(result)) {
        result = _Reset(RST_TYPE_SOFT & RST_TYPES_ALLOWED, apNum);
      }
    }
  }

  // 3. Connect to the DAP and check CPU is halted
  // --------------------------------------------------------------------------------
  // a. Handshake and initialize the Debug Port
  // b. Verify reset indeed occurred
  // c. Verify CPU is halted and in debug mode.
  //    It must be verified in separate step after the reset confirmation to avoid raise conditions
  // d. Clear VC_CORERESET, but leave TRCENA bit enabled. Do it even in failed scenario
  if (SUCCEEDED(result)) {
    result = _DAP_HandshakeAndInit(apNum, TIMEOUT_HANDSHAKE);
    if (SUCCEEDED(result)) {
      v = DHCSR_S_RESET_ST;
      result = _PollMem(DHCSR_ADDR /* 0xE000EDF0 */, v, 0, v, TIMEOUT_LISTEN_WND, 1, &v1);
      if (SUCCEEDED(result)) {
        v = DHCSR_S_HALT | DHCSR_C_DEBUGEN;
        result = _PollMem(DHCSR_ADDR /* 0xE000EDF0 */, v, 0, v, TIMEOUT_LISTEN_WND, 1, &v1);
      }
    }
    resultTmp = _WriteMem(DEMCR_ADDR, DEMCR_TRCENA); // DEMCR (0xE000EDFC) <- TRCENA
    if (FAILED(resultTmp) && SUCCEEDED(result)) {
      result = RESULT_ERR;
    }
  }

  _DebugSWD(result);

  return result;
}

/*********************************************************************
* Performs target acquisition using the alternate, breakpoint-based sequence:
*   1. Pre-reset (do hardware (XRES) or one of the software reset) and connect to the DAP
*   2. Halt CPU, set the hardware breakpoint at the reset address, and issue software reset
*   3. Connect to the DAP and check CPU is halted at breakpoint being set at Reset Address
*   4. Desable/clear breakpoint  
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
* Notes
*   (1) Must not use any high-level functions as it is also called from InitTarget() and uses non-standard APs etc.
*/
int _AcquireBreakpoint(U8 rstType, U8 apNum) {
  int result;
  int resultTmp;
  U32 v;
  U32 v1;
  U32 resetAddress;
  U32 sp;
  U8 doDisableBP;
  
  doDisableBP = 0;

  // 1. Pre-reset and connect
  // --------------------------------------------------------------------------------
  // a. Pre-reset (do hardware (XRES) or one of the software reset) and connect to the DAP
  //    Pre-reset is not critical for the Alternate/Breakpoint acquisition,
  //    so do not check for the result and do not stop if it is failed
  // b. Handshake (wait for debug interface to become enabled after device reset),
  //    initialize the Debug Port and select appropriate Access Port (AP) with the CPU access
  if (apNum == AP_SYS) {
    // It is not possible to handle CPU state (e.g. breakpoints) via the System Access Port
    result = RESULT_ERR;
  } else {
    _Reset(rstType, apNum);
    result = _DAP_HandshakeAndInit(apNum, TIMEOUT_HANDSHAKE);
  }

  // 2. Halt CPU, set the hardware breakpoint at the reset address, and issue software reset
  // --------------------------------------------------------------------------------
  // a. Enable debug and halt CPU as quickly as possible right after Reset+Handshake+InitDAP
  //    It is not mandatory to do this quickly, but there is a good chance to stop
  //    in Listen window or at least prevent user application from doing too much "bad" stuff
  // b. Get Reset Address and Initial SP value from the vector table
  //    Note: Zero in Vector Table base register or in reset address (reset handler + 4) likely indicates that
  //    the target is in VIRGIN (preproduction) state, so the ROM boot code debugging is enabled.
  // c. Enable Breakpoint unit
  // d. Map the address bits to the breakpoint compare register bit-map, set the ENABLE and BPMATCH bits
  //    and update the breakpoint compare register.  
  // e. Issue software reset
  if (SUCCEEDED(result)) {
    result = _HaltCPU();
    if (SUCCEEDED(result)) {
      result = _GetVectorTableData(&resetAddress, &sp);
      if (SUCCEEDED(result)) {
        // FPB->FP_CTRL (0xE0002000) = 0x00000003 (KEY == "1" | ENABLE == "0")
        result = _WriteMem(FP_CTRL, FP_CTRL_KEY | FP_CTRL_ENABLE);
        if (SUCCEEDED(result)) {
          doDisableBP = 1;
          // FPB->FP_COMP0 (0xE0002008) = resetAddress | 0x00000001 (BPADDR == resetAddress, BE == 1)
          result = _WriteMem(FP_COMP0, resetAddress | FP_COMP_BE);
          if(SUCCEEDED(result)) {
            result = _Reset(RST_TYPE_SOFT & RST_TYPES_ALLOWED, apNum);
          }
        }
      }
    }
  }

  // 3. Connect to the DAP and check CPU is halted at breakpoint being set at Reset Address
  // --------------------------------------------------------------------------------
  // a. Handshake and initialize the Debug Port
  // b. Verify reset indeed occurred
  // c. CPU is halted at breakpoint being set at Reset Address
  //    Polling after the reset confirmation is required as a separate step to wait till the boot code finished execution
  //    (Listen window closed) and CPU is halted at the user application entry
  if (SUCCEEDED(result)) {
    result = _DAP_HandshakeAndInit(apNum, TIMEOUT_HANDSHAKE);
    if (SUCCEEDED(result)) {
      v = DHCSR_S_RESET_ST;
      result = _PollMem(DHCSR_ADDR /* 0xE000EDF0 */, v, 0, v, TIMEOUT_LISTEN_WND, 1, &v1);
      if (SUCCEEDED(result)) {
        v = DHCSR_S_HALT | DHCSR_C_DEBUGEN;
        result = _PollMem(DHCSR_ADDR /* 0xE000EDF0 */, v, 0, v, TIMEOUT_LISTEN_WND, 1, &v1);
        if (SUCCEEDED(result)) {
          result = _ReadCoreReg(DCRSR_REGSEL_PC, &v);
          if (SUCCEEDED(result) && ((v | 1) != (resetAddress | 1) )) {
            result = RESULT_ERR;
          }
        }
      }
    }
  }

  // 4. Desable/clear breakpoint even in case of failure to avoid further problems with unexpected breakpoint
  // --------------------------------------------------------------------------------
  if (doDisableBP != 0) {
    // FPB->FP_COMP0 (0xE0002008) = 0 (BPADDR == 0, BE == 0)
    resultTmp = _WriteMem(FP_COMP0, 0);
    if (SUCCEEDED(resultTmp)) {
      // FP_CTRL (0xE0002000) <- 0x00000002 (KEY == "1" | ENABLE == "0")
      resultTmp = _WriteMem(FP_CTRL, FP_CTRL_KEY);
    }
    if (FAILED(resultTmp) && SUCCEEDED(result)) {
      result = RESULT_ERR;
    }
  }  
  
  _DebugSWD(result);
  
  return result;
}

/*********************************************************************
* Performs a variety of CYW208xx chip acquisition attempts:
* 1. Check if the device is already in IDLE or DEAD branches
* 2. Try to acquire in Test mode (TM)
*    This is recommended and the only 100% reliable method.
*    But it will not work if the debugger cannot meet timing requirements or Listen window is disabled.
* 3. Try to acquire using the alternate sequence (breakpoint in RAM)
* Acquisition methods may be invoked twice - with hardware (XRES) and software pre-reset.
* 
* ! Note that an XRES connection is strongly required for the hardware reset.
*   Otherwise, neither of the above methods will work if the firmware does "bad" things such as:
*   - Repurposes the debug pins (intentionally or unintentionally)
*   - Disables/Protects access ports and the Listen window is turned off or too short
*   - Intentionally or unintentionally corrupts values in MMIO registers and the Listen window is turned off or too short
*   In this case, there is no way for the debugger to establish even basic communication with the target
*
* Refer CYW208xx MCUs Programming Specifications: 002-32463
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
* Notes
*   (1) Must not use any high-level functions as it is also called from InitTarget() and uses non-standard APs etc.
*/
int _Acquire(U8* apNum) {
  int result;
  U32 v;
  U8 acqMethods;
  result = RESULT_ERR;
  acqMethods = ACQUIRE_METHODS_ALLOWED;

  if (acqMethods == 0) {
    // Just init DAP if all acquisition methods are disabled
    result = _DAP_HandshakeAndInit(*apNum, TIMEOUT_HANDSHAKE);
  }

  // 1. Check whether the device is already in IDLE or DEAD branch,
  // what is sufficient condition for programming, so Reset/Acquire is not needed.
  if ((acqMethods & ACQUIRE_CHECK_IDLE) != 0) {
    result = _DAP_HandshakeAndInit(*apNum, TIMEOUT_HANDSHAKE_SMALL);
    if (SUCCEEDED(result)) {
      // CYBOOT_ID_FAIL in SRSS->TST_DEBUG_STATUS register indicates that boot code
      // reached the CORRUPTED branch - major system failure occurred (e.g. BIST failed).
      // Debugger has limited MCU access (via System Access Port only), programming/debugging is not possible
      result = _ReadMem(SRSS_TST_DEBUG_STATUS, &v);
      if ((v & CYBOOT_ID_MSK) == CYBOOT_ID_FAIL) {
        result = RESULT_ERR_CRITICAL;
      }
    }
    if (SUCCEEDED(result)) {
      result = _WaitForBootIdle(*apNum, TIMEOUT_LISTEN_WND, 1 /* "1" - Check PC in ROM */);
    }
  }

  // 2. Try to acquire in Test mode (TM)
  // Note: this is time critical, so entire function executed in J-Link firmware and requires __probe attribute for caller
  if (FAILED(result) && (result != RESULT_ERR_CRITICAL) && ((acqMethods & ACQUIRE_TEST_MODE) != 0)) {
    result = _AcquireTestMode(RST_TYPE_HARD & RST_TYPES_ALLOWED, *apNum);
    if (FAILED(result) && (result != RESULT_ERR_CRITICAL)) {
      // If the acquisition failed for some reason (e.g. XRES is not connected), try to acquire in Test mode using software reset
      // This should work if there is no valid user application so the ROM boot code is in WFA state
      // or if the Listen window is wide enough and running application did not disabled or corrupted the debug infrastructure
      result = _AcquireTestMode(RST_TYPE_SOFT & RST_TYPES_ALLOWED, *apNum);
    }
  }

  // Try to acquire using the Vector Catch or the alternate sequence (breakpoint in RAM)
  if (FAILED(result) && (result != RESULT_ERR_CRITICAL) && ((acqMethods & (ACQUIRE_BREAKPOINT | ACQUIRE_VECTOR_CATCH)) != 0)) {
    result = RESULT_OK;
    // If SYS-APP is not strictly preferred, try to find first available AP with CPU access
    if (*apNum == AP_SYS) {
      if (AP_TO_USE_STRICT != 0) {
        result = RESULT_ERR;
      } else {
        result = _DAP_ScanAP(&v);
        if (SUCCEEDED(result)) {
          *apNum = v;
        }
      }
    }
    if (SUCCEEDED(result)) {
      result = RESULT_ERR;
      
      // 4. Try to acquire using the Vector Catch
      if ((acqMethods & ACQUIRE_VECTOR_CATCH) != 0) {
        result = _AcquireVectorCatch(RST_TYPE_HARD & RST_TYPES_ALLOWED, *apNum);
        if (FAILED(result)) {
          result = _AcquireVectorCatch(RST_TYPE_SOFT & RST_TYPES_ALLOWED, *apNum);
        }
      }

      // 5. Try to acquire using the alternate sequence (breakpoint in RAM)
      if (FAILED(result) && (result != RESULT_ERR_CRITICAL) && ((acqMethods & ACQUIRE_BREAKPOINT) != 0)) {
        result = _AcquireBreakpoint(RST_TYPE_HARD & RST_TYPES_ALLOWED, *apNum);
        if (FAILED(result)) {
          // Last chance is to acquire using the alternate method and software pre-reset
          result = _AcquireBreakpoint(RST_TYPE_SOFT & RST_TYPES_ALLOWED, *apNum);
        }
      }
    }
  }
 
  _DebugSWD(result);

  return result;
}

/*********************************************************************
* Configures the SWO pin (P1_0)
* The operations are equal to the following code in ModusToolbox project:
*   Cy_GPIO_Pin_FastInit(GPIO_PRT1, pinNum=0, driveMode=CY_GPIO_DM_STRONG_IN_OFF, outVal=0, hsiom=P1_0_CPUSS_SWJ_SWO_TDO);
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _SWO_SetPin(void) {
  int result;

  JLINK_SYS_Report("JLinkScript: Configuring SWO pin: P1[0]");
  result = _WriteMem(HSIOM_PRT1_PORT_SEL0, 0x1D1D1D1D); // 0x40400010 <- 0x1D1D1D1D
  if (SUCCEEDED(result)) {
    result = _WriteMem(GPIO_PRT1_OUT, 0x0000000C);      // 0x40410080 <- 0x0000000C
    if (SUCCEEDED(result)) {
      result = _WriteMem(GPIO_PRT1_CFG, 0x0000BAA6);    // 0x404100C4 <- 0x0000BAA6
    }
  }
  
  return result;
}

/*********************************************************************
* Configures the TPIU trace clock (assigns a divider to a cpuss.clock_trace_in).
* The operations are equal to the following code in ModusToolbox project:
*   const uint32_t dividerNum = 0u;
*   const cy_en_divider_types_t dividerType = CY_SYSCLK_DIV_24_5_BIT;
*   const en_clk_dst_t ipBlock = PCLK_CPUSS_CLOCK_TRACE_IN_POS_EN;
*   Cy_SysClk_PeriPclkDisableDivider(ipBlock, dividerType, dividerNum);
*   Cy_SysClk_PeriPclkSetFracDivider(ipBlock, dividerType, dividerNum, dividerIntValue=0, dividerFracValue=0);
*   Cy_SysClk_PeriPclkEnableDivider(ipBlock, dividerType, dividerNum);
*   Cy_SysClk_PeriPclkAssignDivider(ipBlock, dividerType, dividerNum); 
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int _SWO_SetTPIUClock(void) {
  int result;

  JLINK_SYS_Report( "JLinkScript: Configuring TPIU clock:");
  JLINK_SYS_Report1("  TRACE_div_sel  = ", TRACE_div_sel);
  JLINK_SYS_Report1("  TRACE_div_int  = ", TRACE_div_int);
  JLINK_SYS_Report1("  TRACE_div_frac = ", TRACE_div_frac);

  // *** Cy_SysClk_PeriPclkDisableDivider ***
  // PERI_DIV_CMD(grpNum) = PERI_DIV_CMD_DISABLE_Msk                        |
  //                        _VAL2FLD(CY_PERI_DIV_CMD_TYPE_SEL, dividerType) |
  //                        _VAL2FLD(CY_PERI_DIV_CMD_DIV_SEL, dividerNum)
  result = _WriteMem(PERI_PCLK_GROUP0_DIV_CMD, 0x40000300 | TRACE_div_sel); // 0x40040000 <- 0x400003<dividerNum>
  if (SUCCEEDED(result)) {

    // *** Cy_SysClk_PeriPclkSetFracDivider ***
    // * The source of the divider is peri_clk, which is a divided version of hf_clk[0].
    // * The divider value causes integer division of (divider value + 1), or division by 1 to 16777216 (24-bit divider).
    // CY_REG32_CLR_SET(PERI_DIV_24_5_CTL(grpNum, dividerNum), PERI_DIV_24_5_CTL_INT24_DIV, dividerIntValue);
    // CY_REG32_CLR_SET(PERI_DIV_24_5_CTL(grpNum, dividerNum), PERI_DIV_24_5_CTL_FRAC5_DIV, dividerFracValue);
    result = _WriteMem(PERI_PCLK_GROUP0_DIV_24_5_CTL + (TRACE_div_sel * 4), ( TRACE_div_int << 8) | (TRACE_div_frac << 3)); // 0x40041C00 <- 0x0
    if (SUCCEEDED(result)) {

      // *** Cy_SysClk_PeriPclkEnableDivider ***
      // PERI_DIV_CMD(grpNum) = PERI_DIV_CMD_ENABLE_Msk                         |
      //                        CY_PERI_DIV_CMD_PA_TYPE_SEL_Msk                 |
      //                        CY_PERI_DIV_CMD_PA_DIV_SEL_Msk                  |
      //                        _VAL2FLD(CY_PERI_DIV_CMD_TYPE_SEL, dividerType) |
      //                        _VAL2FLD(CY_PERI_DIV_CMD_DIV_SEL,  dividerNum);
      result = _WriteMem(PERI_PCLK_GROUP0_DIV_CMD, 0x83FF0300 | TRACE_div_sel); // 0x40040000 <- 0x83FF03<dividerNum>
      if (SUCCEEDED(result)) {

        // *** Cy_SysClk_PeriPclkAssignDivider ***
        // PERI_CLOCK_CTL(grpNum, periNum) = _VAL2FLD(CY_PERI_CLOCK_CTL_TYPE_SEL, dividerType) |
        //                                   _VAL2FLD(CY_PERI_CLOCK_CTL_DIV_SEL, dividerNum);
        result = _WriteMem(PERI_PCLK_GROUP0_CLOCK_CTL + (0 * 4), 0x00000300 | TRACE_div_sel); // 0x40040C00 <- 0x000003<dividerNum>
      }
    }
  }

  return result;
}

/*********************************************************************
*       Global functions
*********************************************************************/

/*********************************************************************
* Called before SWO_GetSWOBaseClock().
* Used for target device that need additional init steps to enable SWO.
* For example if there are none CoreSight registers that need to be enabled
* or more than one pin can be configured to be the SWO pin
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
int SWO_EnableTarget(void) {
  int result;
  result = _SWO_SetPin();
  if (SUCCEEDED(result)) {
    result = _SWO_SetTPIUClock();
  }
  return result;
}

/*********************************************************************
* Determines the actual SWO base clock that is supplied by the device to the SWO CoreSight
* logic. On most devices it is CPUClock / 1 but there are exceptions for which this function
* can be used for
*
* Parameters:
*   CPUClock  Measured CPU clock speed in Hz
* 
* Return value
*   The actual SWO base clock speed
*
*  Notes
*    This function should only be called if the target device has some other SWO base clock
*    than CPUClock / 1.
*/
/*
U32 SWO_GetSWOBaseClock(U32 CPUClock) {
  U32 swo_clock;
  swo_clock = CPUClock >> 1;
  JLINK_SYS_Report( "JLinkScript: SWO_GetSWOBaseClock");
  JLINK_SYS_Report1("  CPUClock  = ", CPUClock);
  JLINK_SYS_Report1("  SWOclock  = ", swo_clock);
  return swo_clock;
}
*/

/*********************************************************************
* If implemented, overwrites the generic SWO initialization
*
* Parameters:
*   Portmask defines which ITM Stimulus ports to enable.
*   TargetDiv-1 is the Async Clock Prescaler Register in the TPIU.
* 
* Return value
*   >= 0  O.K.
*   <  0  Error
*/
/*
int SWO_Generic_Init(U32 PortMask, U32 TargetDiv) {
  int result;
  U32 v;

  JLINK_SYS_Report( "JLinkScript: Doing generic SWO initialization:");
  JLINK_SYS_Report1("  PortMask   = ", PortMask);
  JLINK_SYS_Report1("  TargetDiv  = ", TargetDiv);
  JLINK_SYS_Report1("  SWO_encode = ", SWO_encode);

  // Enables ITM and DWT (set DEMCR.TRCENA bit) before any ITM operations
  result = _ReadMem(DEMCR_ADDR, &v);
  if (SUCCEEDED(result)) {
    _WriteMem(DEMCR_ADDR, v | (1 << 24));
  }

  // Enable the write accesses to the ITM registers by writing the key value to the ITM Lock Access Register. Only for Armv8-M and newer
  result = _WriteMem(ITM_LAR, 0xC5ACCE55);
  if (SUCCEEDED(result)) {
    // Disable the stimulus port and ITM to avoid data transfer via SWO during changing the settings
    result = _WriteMem(ITM_TER0, 0); // Disable all ITM stimulus ports
    if (SUCCEEDED(result)) {
      // It is recommended that the ITMEn bit is cleared and waits for the ITMBusy bit to be cleared,
      // before changing any fields in the Control Register, otherwise the behavior can be unpredictable.
      result = _ReadMem(ITM_TCR, &v);
      if (SUCCEEDED(result)) {
        result = _WriteMem(ITM_TCR, v | (1 << 0));
        if (SUCCEEDED(result)) {
          result = _PollMem(ITM_TCR, (1 << 23), 0, 0, 1000, 1, &v);
        }
      }
    }
  }

  if (SUCCEEDED(result)) {
    // Select the protocol used for trace output:
    //   0b00 - Parallel trace port mode
    //   0b01 - Asynchronous SWO, using Manchester encoding
    //   0b10 - Asynchronous SWO, using NRZ encoding
    result = _WriteMem(TPIU_SPPR, SWO_encode);
    if (SUCCEEDED(result)) {
      // Set the SWO and Parallel trace port baud rate prescaler in the TPIU_ACPR.SWOSCALER field.
      // It is the the ratio between an IMPLEMENTATION DEFINED reference clock and the TPIU output clock rates.
      // SWO or Parallel trace port output clock = Asynchronous_Reference_Clock/(n + 1).
      // In other words, divisor for TRACECLKIN is Prescaler + 1: SWOPrescaler = (CPU_CORE_FREQUENCY_HZ / SWO_SPEED_HZ) + 1
      if (TargetDiv < 1) {
        TargetDiv = 1;
      }
      result = _WriteMem(TPIU_ACPR, TargetDiv-1);
    }
  }

  if (SUCCEEDED(result)) {
    // Set the privilege mask (ITM_TPR.PRIVMASK). Bit[n] of PRIVMASK controls stimulus ports 8n to 8n+7:
    // '0' - Unprivileged access permitted, '1' - Privileged access only.
    result = _WriteMem(ITM_TPR, 0x00000000);
    if (SUCCEEDED(result)) {
      result = _WriteMem(DWT_CTRL, 0x400003FE);
      if (SUCCEEDED(result)) {
        result = _WriteMem(TPIU_FFCR, 0x00000100);
      }
    }
  }

  if (SUCCEEDED(result)) {
    // Enable ITM via the ITM_TCR register
	result = _WriteMem(ITM_TCR, 0x1000D);
    if (SUCCEEDED(result)) {
      // Enable the selected ITM stimulus port
      result = _WriteMem(ITM_TER0, PortMask);
    }
  }
  
  return result;
}
*/

/*********************************************************************
*  Called before InitTarget(). Mainly used to set some global DLL variables to customize the normal connect procedure.
*  For ARM CoreSight devices this may be specifying the base address of some CoreSight components (ETM, ...)
*  that cannot be automatically detected by J-Link due to erroneous ROM tables etc.
*  May also be used to specify the device name in case the debugger does not pass it to the DLL.
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
*  Notes
*    (1) May not, under absolutely NO circumstances, call any API functions that perform target communication.
*    (2) Should only set some global DLL variables
*/
int ConfigTargetSettings(void) {

  JLINK_CORESIGHT_AddAP(AP_SYS, CORESIGHT_CUSTOM_AP); // System Access Port
  JLINK_CORESIGHT_AddAP(AP_CM33, CORESIGHT_AHB_AP);   // Cortex-M33 Access Port
  JLINK_CORESIGHT_IndexAHBAPToUse = AP_TO_USE;        // Index of AHB-AP to use for communication with core
  JLINK_ExecCommand("CORESIGHT_SetTPIUBaseAddr = 0xE008E000");
  CPU=CORTEX_M33;

  return RESULT_OK;
}

/*********************************************************************
* Replaces the target-CPU-auto-find procedure of the J-Link DLL.
* Useful for target CPUs that are not accessible by default and need some special steps
* to be executed before the normal debug probe connect procedure can be executed successfully.
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
* Notes
*   (1) If target interface JTAG is used: JTAG chain has to be specified manually before leaving this function
*       (meaning all devices and their TAP IDs have to be specified by the user).
*       Also appropriate JTAG TAP number to communicate with during the debug session has to be manually specified in this function.
*   (2) MUST NOT use any MEM_ API functions
*   (3) Global DLL variable “CPU” MUST be set when implementing this function, so the DLL knows which CPU module to use internally.
*   (4) __probe attribute specifies that this function is executed in the J-Link firmware rather than on the PC side,
*       so changes to global variables may only be temporarily valid inside this function (not guaranteed to be valid later)
*/
__probe int InitTarget(void) {
  int result;
  U8 apNum;
  apNum = AP_TO_USE;
  result = RESULT_OK;

  // Handshake with small timeout for initial probing
  // If DAP is not accessible, it is possible that the user's firmware repurposed the debug pins to be used as GPIO or did other bad staff
  // disabling the debug port. In this case, acquire the device either in Test mode (TM) or using the alternate sequence.
  // Note: TM sequence is time-critical, so executed in J-Link firmware and requires __probe attribute for the caller
  result = _Handshake(TIMEOUT_HANDSHAKE_SMALL);
  if (FAILED(result)) {
    result = _Acquire(&apNum);
  }

  if (SUCCEEDED(result)) {
    JLINK_ExecCommand("SetETBIsPresent = 1"); // ETB is available
  }

  return result;
}

/*********************************************************************
* Replaces reset strategies of DLL.
* No matter what reset type is selected in the DLL, if this function is present, it will be called instead of the DLL internal reset.
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
* Notes
*   (1) DLL expects target CPU to be halted / in debug mode, when leaving this function
*   (2) May use MEM_ API functions
*   (3) __probe attribute specifies that this function is executed in the J-Link firmware rather than on the PC side,
*       so changes to global variables may only be temporarily valid inside this function (not guaranteed to be valid later)
*/
__probe int ResetTarget(void) {
  int result;
  U8 apNum;
  apNum = AP_TO_USE;
  result = RESULT_OK;

  // Acquire target in Test mode (TM) or use the alternate acquisition method (e.g. breakpoint at reset address).
  // Note: TM acquisition is time-critical, so entire function executed in J-Link firmware and requires __probe attribute for caller
  result = _Acquire(&apNum);
  if (SUCCEEDED(result)) {
    result = _HaltCPU();
    if (SUCCEEDED(result)) {
      // Enable DWT, ITM, TPIU, and ETM units by setting TRCENA bit in DEMCR register
      result = _WriteMem(DEMCR_ADDR, DEMCR_TRCENA); // DEMCR (0xE000EDFC) <- TRCENA
    }
  }

  return result;
}

/*********************************************************************
* Called right after flash programming Usually used to restore initialized peripherals
* which have been used during the flash download like for example clocks or port pins
* (e.g. QSPI alternate function)
*
* Return value
*   >= 0  O.K.
*   <  0  Error
*
* Notes / Limitations
*    (1) DLL expects target CPU to be halted / in debug mode, when leaving this function
*    (2) May use MEM_ API functions
*/
int HandleAfterFlashProg(void) {
  int result;

  // Do hardware or software reset.
  // Otherwise, device remains acquired because the reset command sent by IDE after programming,
  // calls the ResetTarget function, which will acquire the target again.
  // This is required to start the application for normal execution and for "Attach" actions after programming.
  result = _Reset(RST_TYPES_ALLOWED, AP_TO_USE);
  return result;
}

/*************************** end of file ****************************/
